---
layout: single
title: "Numpy"
categories: python
tag: [colab, numpy]
toc: true
author_profile: false
sidebar:
  nav: "docs"
typora-root-url: ../
---

# Colab

구글에서 제공하는 Colab

브라우저에서 python을 작성하고, 실행 가능한 어플리케이션

클라우드 기반으로 한 주피터 노트북 개발환경

컴퓨터에 gpu가 없거나, 사양이 낮다면...
=> 이걸 사용하기 좋음 !

별도의 Python 설치가 필요 없음 !

데이터의 분석에 사용하는 numpy, pandas, keras, scikit-learn, tenserflow, ... 패키지가 기본적으로 설치가 되어있음 !

다른 주피터 노트북보다 더 좋은 기능, 환경을 제공

명령어

Ctrl + Enter : 해당 코드 셀을 실행

Shift + Enter : 해당 코드 셀을 실행하고 다음 코드 셀로 넘어감

Ctrl + M + Z : 실행 취소

Ctrl + M + D : 셀 지우기

Ctrl + ; : 메모장 셀 만들기

도구 탭 - 단축키... 설정

<hr>

# Numpy (Numerical Python)



C언어 기반 파이썬 라이브러리

고성능의 수치계산 및 과학 계산을 위한 라이브러리 +

수치 연산을 수행하는 선형대수(Linear algebra) 라이브러리

List의 확장판(데이터 연산, 통계 분석) 느낌

다차원 배열을 처리하는데 필요한 여러 유용한 기능 제공 => 데이터 분석을 할 때 사용하는 라이브러리인 pandas와 matplotlib의 기반으로  사용되기도 함

단순하게 [다차원 배열로 표현]한다 라고 이해하면 좋다

### 모든 배열의 값이 기본적으로 같은 자료형이어야 함

Numpy에서는 각 차원(Dimension)을 축(axis)으로 표현

핵심적인 기능 : ndarray 객체

ndarray객체는 동일한 자료형의 n-차원 배열을 모아주는 역할

배열의 차원 : rank, 각 차원의 크기를 tuple로 표시 : shape

ex) 2행 3열인 경우 : 2차원 배열에서의 rank는 2, shape는 (2, 3)

numpy배열을 생성하는 방법

1. python list
2. numpy 제공 함수

```python
import numpy as np
import matplotlib.pyplot as plt
```

list : 하나의 리스트 안에 숫자, 문자 섞여서 들어가는게 가능 O

numpy : 항상 !!! 같은 타입의 데이터만 들어갈 수 있음 !

# Part 1. Numpy ndarray

Numpy의 핵심 기능 : ndarray

ndarray : 다차원의 배열 객체 / 파이썬에서 대규모 데이터 집합을 담을 수 있는 빠르고 유연한 자료구조

용어정리
- scalar : 상수 값(10, 3.141592, 'Korea')
- vector(1차원) : [10, 20, 30]
- metrix(2차원) : [[10, 20, 30], [100, 200, 300]] 2 x 3
- 3차원 : [[[10, 20, 30], [100, 200, 300]], [[10, 20, 30], [100, 200, 300]]] 2 x 2 x 3

```python
data1 = [1, 2, 3, 4, 5]
data1

[1, 2, 3, 4, 5]
```

```python
data2=[1, 2, 3, 3.5, 4]
data2

[1, 2, 3, 3.5, 4]
```

```python
# numpy를 이용해서 array 정의하기

# 1. 위에서 만든 python list를 이용

arr1 = np.array(data1)
print(arr1)

arr2 = np.array(data2)
arr2

[1 2 3 4 5]
array([1. , 2. , 3. , 3.5, 4. ])
```

```python
# python list를 넣어서 만들기
a = np.array([1, 2, 3])
print(a, type(a))

[1 2 3] <class 'numpy.ndarray'>
```

```python
# ndarray 생성방법 2

arr3 = np.arange(1, 11) # 1 ~ (11 -1)까지
arr3

array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
```

```python
# ndarray 생성방법 3

arr4 = np.random.randint(1, 11, size=5) # 1 ~ 10까지의 숫자를 랜덤하게 5개 뽑기
arr4

array([ 8,  1, 10,  8,  4])
```

# np.random 관련함수

- np.random.rand()
- np.random.randint()
- np.random.randn()
- np.random.choice()

```python
np.random.rand(5) # 0 ~ 1 사이의 랜덤한 실수값 반환 (5개)

array([0.17166709, 0.24120285, 0.51347626, 0.37170188, 0.50848358])
```

```python
np.random.randint(10) # 0 ~ (10 - 1)까지의 랜덤한 정수값 반환

2
```

```python
np.random.randn(5) # 표준 정규분포 값 5개를 반환 (평균 0, 편차 1)

array([-0.24674938,  0.46735653, -1.88133313, -0.47835974, -0.74410296])
```

```python
np.random.choice([1, 2, 3, 4, 5]) # 배열 안의 값 중 랜덤한거 하나 뽑아서 반환

1
```

```python
# List와 비교
l = [1, 2, 3]                 # 콤마로 구분
a = np.array([1, 2, 3])       # 띄어쓰기로 구분
print(l)
print(a)

[1, 2, 3]
[1 2 3]
```

```python
# numpy 반복문
for i in a:
  print(i)
  
1
2
3  
```

```python
# list에서 append
l.append(4) # 뒤에 숫자 4가 포함
print(l)

# numpy에서의 append >> (list의 방법으로는) 불가능

[1, 2, 3, 4]
```

```python
# numpy에서의 append >> np.append()으로 대상 배열 콕 찝어서 ...!
a = np.append(a, 4)
print(a)

[1 2 3 4]
```

```python
# list에서의 덧셈 >> 뒤에 숫자 5가 추가
l = l + [5]
print(l)

[1, 2, 3, 4, 5]
```

```python
# numpy에서의 덧셈 >> 각각의 요소에 + 5
a = a + np.array([5])
print(a)

[6 7 8 9]
```

```python
# list의 모든 요소를 2배로 만들기
l = [1, 2, 3]
l2 = []
for i in l:
  l2.append(i*2)
print(l2)

[2, 4, 6]
```

```python
l = l * 2
print(l)

[1, 2, 3, 1, 2, 3]
```

```python
# ndarray의 모든 요소를 2배로 만들기
a = np.array(l)
a = a * 2
print(a)

# Numpy에서는 산술 연산 O

[2 4 6 2 4 6]
```

# Part 2. 배열

Numpy 배열은 모두 같은 자료형의 값이고, 음수가 아닌 정수의 튜플로 인덱싱

배열의 shape는 각 차원별 배열 크기의 tuple

중첩된 파이썬 리스트로부터 numpy 배열을 초기화 할 수 있고,

대괄호를 사용해서 요소로 접근 가능 O

```python
ex = [[1, 2, 3], [4, 5, 6], [7,8,9]]
print(ex) # list 속에 list
print(np.array(ex))
exx = np.array(ex)
exx.shape # shape로 확인함으로써 몇 개의 데이터가 있는지, 몇 차원으로 존재하는지 알 수 있음

[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
(3, 3)
```

```python
a = np.array([1,2,3])
print(a)

# ndim : 몇 차원인지
# shape : array의 형태(크기)를 확인
# (3, ) : (1차원이라서) 튜플 형식이기 때문에, 뒤에가 비어있고 콤마로 구분
# dtype : 배열 요소의 자료형
print(type(a), a.ndim, a.shape, a.dtype)

# [1 2 3]
# <class 'numpy.ndarray'> 1 (3,) int64
```

# Array 연산

기본적으로 numpy에서 연산을 하는 경우

서로 크기가 같은 array끼리 연산을 진행

같은 위치에 있는 요소들끼리 연산을 진행

```python
arr1 = np.array([[1,2,3], [4,5,6]])
arr1

array([[1, 2, 3],
       [4, 5, 6]])
```

```python
arr2 = np.array([[10,11,12], [13,14,15]])
arr2

array([[10, 11, 12],
       [13, 14, 15]])
```

```python
print(arr1.shape, arr2.shape) # 크기가 서로 동일한 array

(2, 3) (2, 3)
```

```python
# arr1, arr2 사칙연산

# 덧셈
print(arr1 + arr2)
# 뺄셈
print(arr1 - arr2)
# 나눗셈
print(arr1 / arr2)
# 곱셈
print(arr1 * arr2)
print(arr1 % arr2)
print(arr1 // arr2)

[[11 13 15]
 [17 19 21]]
[[-9 -9 -9]
 [-9 -9 -9]]
[[0.1        0.18181818 0.25      ]
 [0.30769231 0.35714286 0.4       ]]
[[10 22 36]
 [52 70 90]]
[[1 2 3]
 [4 5 6]]
[[0 0 0]
 [0 0 0]]
```

# Array BroadCasting

브로드캐스팅(BroadCasting)은 모양이 다른 배열들 간의 연산이 어떤 조건이 갖춰졌을 때(만족했을 때) 가능해지도록 배열을 자동적으로 변환하는 것

=> 서로 크기가 다른 array들의 연산이 가능해졌다 !!

# 조건
1. 원소가 하나인 배열은 어떤 배열이나 브로드캐스팅이 가능
2. 하나의 배열이 1차원 배열인 경우, 브로드캐스팅이 가능

ex) arr1.shape(3, ) / arr2.shape(3, 3)
3. 차원의 짝이 맞을 때 브로드캐스팅이 가능

ex) arr1.shape(4, 1) / arr2.shape(1, 4)

```python
arr1

array([[1, 2, 3],
       [4, 5, 6]])
```

```python
arr3=np.array([7,8,9])
arr3

array([7, 8, 9])
```

```python
print(arr1.shape, arr3.shape)

(2, 3) (3,)
```

```python
# arr1, arr3 사칙연산

print(arr1 + arr3)
print()
print(arr1 - arr3)
print()
print(arr1 * arr3)
print()
print(arr1 / arr3)

# arr3의 array([7,8,9])가
# 2번 조건에 만족해서
# [[7,8,9], [7,8,9]]로 확장이 되어서 계산이 가능!

[[ 8 10 12]
 [11 13 15]]

[[-6 -6 -6]
 [-3 -3 -3]]

[[ 7 16 27]
 [28 40 54]]

[[0.14285714 0.25       0.33333333]
 [0.57142857 0.625      0.66666667]]
```

```python
# 스칼라(Scalar) 연산
# 스칼라는 방향은 없지만, 실수 공간에서만 크기만 나타내는 값
# 실수 전체집합에 속하는 값
arr1 * 10

array([[10, 20, 30],
       [40, 50, 60]])
```

```python
# np.array() vs np.asarray()
b = np.asarray(a)
print(a)
print(b)

[1 2 3]
[1 2 3]
```

```python
b[0] = 9
print(a)
print(b)

[9 2 3]
[9 2 3]
```

```python
c = np.array(a)
print(c)

[9 2 3]
```

```python
c[0] = 1
print(a)
print(b)
print(c)

# asarray()는 사본이 없는 개념(수정내용 공유)
# array()는 사본이 있는 개념

[9 2 3]
[9 2 3]
[1 2 3]
```

```python
# np.zeros() 함수는 파라미터로 받는 크기만큼, 모든 요소가 0인 array를 생성
a = np.zeros(3)
print(a)
aa = np.zeros((3,4))
print(aa)

[0. 0. 0.]
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]
```

```python
# np.ones() 함수는 파라미터로 받는 크기만큼, 모든 요소가 1인 array를 생성
b = np.ones(5)
print(b)
bb = np.ones((5,2))
print(bb)

[1. 1. 1. 1. 1.]
[[1. 1.]
 [1. 1.]
 [1. 1.]
 [1. 1.]
 [1. 1.]]
```

```python
# np.full()
c = np.full((2,3), 4)
print(c)

[[4 4 4]
 [4 4 4]]
```

```python
i = np.eye(3,5)     # 대각행렬 : 대각선이 1인 행렬을 생성
j = np.identity(5)  # 단위행렬 : 대각선의 요소가 모두 1, 나머지는 0
print(i)
print(j)

[[1. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0.]]
[[1. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0.]
 [0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 1.]]
```

```python
# seed를 지정해주지 않으면, 매번 다른 난수가 나타남
np.random.seed(3)
np.random.rand(4)

array([0.5507979 , 0.70814782, 0.29090474, 0.51082761])
```

```python
plt.style.available # matplotlib 테마종류

['Solarize_Light2',
 '_classic_test_patch',
 '_mpl-gallery',
 '_mpl-gallery-nogrid',
 'bmh',
 'classic',
 'dark_background',
 'fast',
 'fivethirtyeight',
 'ggplot',
 'grayscale',
 'seaborn-v0_8',
 'seaborn-v0_8-bright',
 'seaborn-v0_8-colorblind',
 'seaborn-v0_8-dark',
 'seaborn-v0_8-dark-palette',
 'seaborn-v0_8-darkgrid',
 'seaborn-v0_8-deep',
 'seaborn-v0_8-muted',
 'seaborn-v0_8-notebook',
 'seaborn-v0_8-paper',
 'seaborn-v0_8-pastel',
 'seaborn-v0_8-poster',
 'seaborn-v0_8-talk',
 'seaborn-v0_8-ticks',
 'seaborn-v0_8-white',
 'seaborn-v0_8-whitegrid',
 'tableau-colorblind10']
```

```python
# numpy + matplotlib
np.random.seed(0)

# theme 바꾸기
plt.style.use('default') # 기본 디자인

# matplotlib 설정
# 그래프의 기본크기(가로, 세로) 인치
plt.rcParams['figure.figsize'] = (6,3)
plt.rcParams['font.size'] = 10
# lines.linewidth : 선 두께
# lines.color : 선 색깔
# axes.grid : 그래프 내 격자선(grid) 표시 여부

# 샘플 데이터
a = np.random.rand(1000)
b = np.random.rand(10000)
c = np.random.rand(100000)

# hist : 도수분포표(히스토그램)
# 자료의 분표를 몇 개의 구간으로 나누고, 나누어진 각 구간에 속하는 자료가 몇 개인지 정리한 표
# bin : 히스토그램의 가로축 구간의 갯수
# density=True : 각 구간의 밀도(밀도 함수)
# alpha : 투명도 (0.0 ~ 1.0)
# histtype : 종류 지정(bar, barstacked, step, stepfilled), default는 bar
plt.hist(a, bins=100, density=True, alpha=0.5, histtype="stepfilled", label="n=1000")
plt.hist(b, bins=100, density=True, alpha=0.5, histtype="step", label="n=10000")
plt.hist(c, bins=100, density=True, alpha=0.5, histtype="step", label="n=100000")

plt.ylim(0,2)
plt.legend()
plt.show()
# 샘플의 갯수가 증가할수록, 더욱 균일한 분포를 보인다...!
```

![img](data:image/png;base64,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)

```python
# 정규분포(normarl distribution, 가우스 분포)
# 표준정규분포(standard normal distribution)에서 샘플링된 난수를 반환
# 매개 변수 평균인 뮤와(mu, μ)
# 표준편자 (분산을 제곱근) σ(sigma)에 대해 모양이 결정
# 평균이 0이고, 표준편차가 1인 정규분포
```

```python
# 배열의 dtype(data type)

a = np.array([1,2,3])
b = np.array([1,2,3], dtype=np.float64)
c = np.array([1,2,3], dtype=np.int32)

print(a.dtype, b.dtype, c.dtype)

# 뒤에 숫자 : ex) int 64 => 정수로 표현 ... 2^64만큼의 범위만큼 (음수, 양수)

int64 float64 int32
```

```python
d = np.array([1,2,3], dtype='i1')
e = np.array([1,2,3], dtype='i2')
f = np.array([1,2,3], dtype='i4')
g = np.array([1,2,3], dtype='i8')

print(d.dtype, e.dtype, f.dtype, g.dtype)

int8 int16 int32 int64
```

```python
d = np.array([1,2,3], dtype='u1')
e = np.array([1,2,3], dtype='u2')
f = np.array([1,2,3], dtype='u4')
g = np.array([1,2,3], dtype='u8')

print(d.dtype, e.dtype, f.dtype, g.dtype)
# 양수만 표현이 가능

uint8 uint16 uint32 uint64
```

```python
h = np.array([1,2,3], dtype='f2')
i = np.array([1,2,3], dtype='f4')
j = np.array([1,2,3], dtype='f8')

print(h.dtype, i.dtype, j.dtype)

float16 float32 float64
```

```python
i = np.array([1,2,3], dtype='f')
j = np.array([1,2,3], dtype='d')
k = np.array([1,2,3], dtype='g')
print(h.dtype, i.dtype, j.dtype, k.dtype)

# 형변환
i = i.astype(np.int32)
print(i.dtype)

float32 float32 float64 float128
int32
```

```python
ex = [[1,2,3], [4,5,6], [7,8,9]]
ex1 = np.array(ex)
print(ex1.dtype)
print(type(ex1))
print(dir(ex1)) # 사용할 수 있는 함수를 보여줌

print(np.nan) # nan : 평균같은거 구하고 싶을 때 제외하고 싶은 것을 nan으로 표시

int64
<class 'numpy.ndarray'>
['T', '__abs__', '__add__', '__and__', '__array__', '__array_finalize__', '__array_function__', '__array_interface__', '__array_prepare__', '__array_priority__', '__array_struct__', '__array_ufunc__', '__array_wrap__', '__bool__', '__class__', '__class_getitem__', '__complex__', '__contains__', '__copy__', '__deepcopy__', '__delattr__', '__delitem__', '__dir__', '__divmod__', '__dlpack__', '__dlpack_device__', '__doc__', '__eq__', '__float__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__iand__', '__ifloordiv__', '__ilshift__', '__imatmul__', '__imod__', '__imul__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__lshift__', '__lt__', '__matmul__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmatmul__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__setitem__', '__setstate__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__xor__', 'all', 'any', 'argmax', 'argmin', 'argpartition', 'argsort', 'astype', 'base', 'byteswap', 'choose', 'clip', 'compress', 'conj', 'conjugate', 'copy', 'ctypes', 'cumprod', 'cumsum', 'data', 'diagonal', 'dot', 'dtype', 'dump', 'dumps', 'fill', 'flags', 'flat', 'flatten', 'getfield', 'imag', 'item', 'itemset', 'itemsize', 'max', 'mean', 'min', 'nbytes', 'ndim', 'newbyteorder', 'nonzero', 'partition', 'prod', 'ptp', 'put', 'ravel', 'real', 'repeat', 'reshape', 'resize', 'round', 'searchsorted', 'setfield', 'setflags', 'shape', 'size', 'sort', 'squeeze', 'std', 'strides', 'sum', 'swapaxes', 'take', 'tobytes', 'tofile', 'tolist', 'tostring', 'trace', 'transpose', 'var', 'view']
nan
```

```python
b[0] = np.nan
print(b)

# c = np.arange(1,10).reshape(3,3) # ValueError: cannot convert float NaN to integer / nan은 float만 가능 O
# c[1][1] = np.nan
# print(c)

[nan  2.  3.]
```

# Part 3. 배열 indexing(색인)과 slicing(슬라이싱)

```python
a = np.arange(10)
print(a)

[0 1 2 3 4 5 6 7 8 9]
```

```python
# indexing : 특정한 index번호에 접근해서 그 값을 가져오는 작업
# a에서 5번째에 있는 값 출력
print(a[5])

5
```

```python
# np.arange() 함수는 파라미터로 받는 값만큼 1씩 증가하는 1차원의 array를 만듦
# 이때 하나의 파라미터만 입력하면 0 ~ (입력한 값 - 1)만큼의 크기를 가짐

# 두 개의 파라미터를 넣으면 시작값 ~ (끝 값 - 1)만큼의 크기를 가짐
kk = np.arange(3, 10)
kk

array([3, 4, 5, 6, 7, 8, 9])
```

```python
# slicing : 연속적인 객체(배열, 리스트, ...)에 부여된 번호를 이용해서
#           그 일부를 추출하는 작업
print(a)
# a에서 5,6,7 값 출력
print(a[5:8])

# 맨 뒤에 있는 요소의 값
print(a[-1])

# 시작부터 7번째까지 2개씩 띄워서 출력
print(a[0:8:2])
print(a[:8:2])

[0 1 2 3 4 5 6 7 8 9]
[5 6 7]
9
[0 2 4 6]
[0 2 4 6]
```

```python
ex = [[1,2,3],[4,5,6],[7,8,9]]
exx=np.array(ex)
print(exx.shape)

# 콤마를 이용해서 slicing
# 1행에 대한 값만 추출
print(exx[: 1, ])

# 1열에 대한 값만 추출
print(exx[: ,1])

(3, 3)
[[1 2 3]]
[2 5 8]
```

# Indexing과 Slicing의 차이

Indexing을 사용하면 항상 랭크(차원) 감소

Slicing을 사용하면 랭크(차원) 유지

```python
# 몇 차원인가...? 대괄호의 갯수로 파악하면 !
# b = np.arange(1, 13).reshape(3,4)
b = np.arange(1, 13).reshape(3,2,2)
print(b)
print(b.ndim)

[[[ 1  2]
  [ 3  4]]

 [[ 5  6]
  [ 7  8]]

 [[ 9 10]
  [11 12]]]
3
```

```python
indexing = b[1]
slicing = b[1:2]
print(indexing, indexing.shape, indexing.ndim)
print(slicing, slicing.shape, slicing.ndim)

[[5 6]
 [7 8]] (2, 2) 2
[[[5 6]
  [7 8]]] (1, 2, 2) 3
```

```python
# arange 사용시
# reshape 재배열 - 요소의 갯수만큼 크기를 지정해야 ...!
print(np.arange(1,13).reshape(3,4))
# print(np.arange(1,13).reshape(3,3)) # ValueError: cannot reshape array of size 12 into shape (3,3)

[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
```

```python
# array 수정

arr = np.array([11,22,33,44,55])
print(arr)

# 0번째 인덱스에 있는 값을 10으로 변경
arr[0] = 10
print(arr)

# 1번째, 2번재 인덱스에 있는 값을 222, 333으로 변경
arr[1:3]=[222,333]
print(arr)
# 3번째, 4번째 인덱스에 있는 값에 2를 더하기
arr[3:5] += 2
print(arr)

[11 22 33 44 55]
[10 22 33 44 55]
[ 10 222 333  44  55]
[ 10 222 333  46  57]
```

```python
arr = np.array([110, 222, 337, 420, 155, 978, 200, 53, 178])
print(arr)
print(arr.shape)
# arr에서 200보다 큰 데이터에 대해 기존 값에 2를 더한 값으로 수정
for i in range(0, arr.shape[0]):
  if (arr[i] > 200):
    arr[i] += 2
print(arr)

[110 222 337 420 155 978 200  53 178]
(9,)
[110 224 339 422 155 980 200  53 178]
```

```python
arr = np.array([110, 222, 337, 420, 155, 978, 200, 53, 178])
print(arr)

# 인덱스 안에서 조건을 걸 수 있음
arr[arr > 200] += 2
print(arr)

[110 222 337 420 155 978 200  53 178]
[110 224 339 422 155 980 200  53 178]
```

```python
# array 삭제

arr = np.array([11,22,33,44,55])
print(arr)

# 0번째, 2번째 인덱스에 있는 값을 삭제
# np.delete(array, index)
arr = np.delete(arr, [0, 2])
print(arr)

[11 22 33 44 55]
[22 44 55]
```

```python
# array 인덱스 추출
# np.where(조건)

# arr의 각 요소의 값이 100보다 작은 index 추출
np.where(arr < 100)
# index가 정리되어서 나타나는걸 확인할 수 있음 !

(array([0, 1, 2]),)
```

```python
arr = np.array([11,130,370,114,55,94,200,30,190,187])

# np.where의 기능을 살펴보고,
# arr의 각 요소의 값이 100 이상이면 'A' 아니면 'B'를 출력
np.where(arr>=100, 'A', 'B')

array(['B', 'A', 'A', 'A', 'B', 'B', 'A', 'B', 'A', 'A'], dtype='<U1')
```

# Numpy 함수

하나의 array에 적용 (단항 유니버셜함수)

유니버셜 함수 : ndarray안에 있는 데이터의 요소별로 연산을 수행해주는 함수

```python
ar1 = np.random.randn(5,3)
ar1

array([[ 0.286409  ,  0.13067066,  0.30325788],
       [-1.96902231, -0.37734203, -0.34181404],
       [-1.16029309,  0.60777169,  0.91773521],
       [-0.74738935, -0.30761323, -1.18502116],
       [ 0.1065359 ,  1.51861521,  0.77255105]])
```

```python
# 각 요소의 절대값
np.abs(ar1)

array([[0.286409  , 0.13067066, 0.30325788],
       [1.96902231, 0.37734203, 0.34181404],
       [1.16029309, 0.60777169, 0.91773521],
       [0.74738935, 0.30761323, 1.18502116],
       [0.1065359 , 1.51861521, 0.77255105]])
```

```python
# 각 요소의 제곱근 계산 (== ar1 ** 0.5)
np.sqrt(ar1)

<ipython-input-140-8a404fa25271>:2: RuntimeWarning: invalid value encountered in sqrt
  np.sqrt(ar1)
array([[0.53517193, 0.36148396, 0.55068855],
       [       nan,        nan,        nan],
       [       nan, 0.77959713, 0.95798497],
       [       nan,        nan,        nan],
       [0.32639838, 1.23232106, 0.87894883]])
```

```python
# 각 요소의 제곱 계산
np.square(ar1)

array([[0.08203011, 0.01707482, 0.09196534],
       [3.87704886, 0.14238701, 0.11683684],
       [1.34628006, 0.36938642, 0.84223792],
       [0.55859084, 0.0946259 , 1.40427514],
       [0.0113499 , 2.30619215, 0.59683512]])
```

```python
# 각 요소를 자연로그, 상용로그, 아래가 2인 로그를 씌운 값 계산
print(np.log(ar1))
print()
print(np.log10(ar1))
print()
print(np.log2(ar1))
print()

[[-1.25033443 -2.0350752  -1.19317174]
 [        nan         nan         nan]
 [        nan -0.49795598 -0.08584637]
 [        nan         nan         nan]
 [-2.23927327  0.41779887 -0.25805719]]

[[-0.54301334 -0.88382193 -0.5181879 ]
 [        nan         nan         nan]
 [        nan -0.21625954 -0.03728261]
 [        nan         nan         nan]
 [-0.97250402  0.18144774 -0.11207281]]

[[-1.80385128 -2.9359929  -1.72138295]
 [        nan         nan         nan]
 [        nan -0.71839863 -0.12385013]
 [        nan         nan         nan]
 [-3.23058844  0.60275636 -0.37229783]]

<ipython-input-143-ba8fbee6fc4a>:2: RuntimeWarning: invalid value encountered in log
  print(np.log(ar1))
<ipython-input-143-ba8fbee6fc4a>:4: RuntimeWarning: invalid value encountered in log10
  print(np.log10(ar1))
<ipython-input-143-ba8fbee6fc4a>:6: RuntimeWarning: invalid value encountered in log2
  print(np.log2(ar1))
```

```python
# 각 요소의 부호 나타내기 (+ : 1, - : -1, 0 : 0)
np.sign(ar1)

array([[ 1.,  1.,  1.],
       [-1., -1., -1.],
       [-1.,  1.,  1.],
       [-1., -1., -1.],
       [ 1.,  1.,  1.]])
```

```python
# 각 요소의 소수 첫번째 자리에서 올림한 값 계산
np.ceil(ar1)

array([[ 1.,  1.,  1.],
       [-1., -0., -0.],
       [-1.,  1.,  1.],
       [-0., -0., -1.],
       [ 1.,  2.,  1.]])
```

```python
# 각 요소의 소수 첫번째 자리에서 내림한 값 계산
np.floor(ar1)

array([[ 0.,  0.,  0.],
       [-2., -1., -1.],
       [-2.,  0.,  0.],
       [-1., -1., -2.],
       [ 0.,  1.,  0.]])
```

```python
# 각 요소의 소수 첫번째 자리에서 반올림한 값 계산
np.round(ar1)

array([[ 0.,  0.,  0.],
       [-2., -0., -0.],
       [-1.,  1.,  1.],
       [-1., -0., -1.],
       [ 0.,  2.,  1.]])
```

```python
# 각 요소가 nan인 경우 True, 아닌 경우 False를 반환
np.isnan(ar1)

array([[False, False, False],
       [False, False, False],
       [False, False, False],
       [False, False, False],
       [False, False, False]])
```

```python
# 각 요소가 무한대인 경우 True, 아닌 경우 False를 반환
np.isinf(ar1)

array([[False, False, False],
       [False, False, False],
       [False, False, False],
       [False, False, False],
       [False, False, False]])
```

```python
# 각 요소에 대해 삼각함수 값을 계산하기(cos, cosh, sin, sinh, tan, tanh)
# ~h : 쌍곡선 함수
# 쌍곡선 : 고정된 두 초점으로부터 거리가 일정한 점들에 의해 나타나는 곡선
np.cos(ar1)

array([[ 0.95926455,  0.99147473,  0.95436865],
       [-0.38778375,  0.92964725,  0.94214816],
       [ 0.39907081,  0.82092251,  0.60762047],
       [ 0.73346589,  0.95305896,  0.37627745],
       [ 0.99433042,  0.05215744,  0.71613246]])
```

# 두 개의 array에 적용(이항 유니버셜 함수)

```python
ar1

array([[ 0.286409  ,  0.13067066,  0.30325788],
       [-1.96902231, -0.37734203, -0.34181404],
       [-1.16029309,  0.60777169,  0.91773521],
       [-0.74738935, -0.30761323, -1.18502116],
       [ 0.1065359 ,  1.51861521,  0.77255105]])
```

```python
ar2 = np.random.randn(5,3)
ar2

array([[-1.0014254 , -2.19371795,  0.32501273],
       [-0.6440759 , -0.1811336 , -1.10456151],
       [-2.18186928, -0.22438668, -0.01734533],
       [ 0.35362082, -0.07254749,  1.88096993],
       [-0.23157872,  0.87933173,  1.16659525]])
```

```python
# 두 개의 array에 대해 동일한 위치 요소끼리
# 연산 값을 계산함수(add, subtract, multiply, divide)
np.multiply(ar1, ar2)

array([[-0.28681724, -0.28665456,  0.09856267],
       [ 1.26819982,  0.06834932,  0.37755463],
       [ 2.53160785, -0.13637587, -0.01591842],
       [-0.26429243,  0.02231657, -2.22898916],
       [-0.02467145,  1.33536653,  0.90125438]])
```

```python
# 두 개의 array에 대해 동일한 위치의 요소끼리 비교해서 최대값 or 최소값 계산
# (maximum, minimum)
np.maximum(ar1, ar2)

array([[ 0.286409  ,  0.13067066,  0.32501273],
       [-0.6440759 , -0.1811336 , -0.34181404],
       [-1.16029309,  0.60777169,  0.91773521],
       [ 0.35362082, -0.07254749,  1.88096993],
       [ 0.1065359 ,  1.51861521,  1.16659525]])
```

# 통계 함수

통계 함수를 통해 array의 합이나 평균 등을 구할 때 추가로 'axis'라는 파라미터에 대한 값을 지정해서 열 또는 행의 합 또는 평균 등을 구할 수 있음!

```python
# 열 간의 합을 계산
np.sum(ar1, axis=0)

array([-3.48375985,  1.57210228,  0.46670894])
```

```python
# 행 간의 합을 계산
np.sum(ar1, axis=1)
```

```python
# 전체 요소의 평균을 계산
np.mean(ar1)

-0.09632990869587234

```

```python
# 전체 요소의 표준편차, 분산, 최소값, 최대값 (std, var, min, max)
np.std(ar1)

0.8838523504223659
```

```python
# 전체 요소의 최소값, 최대값이 위치한 인덱스 위치를 반환(argmin, argmax)
np.argmin(ar1)

3
```

```python
# 맨 처음 요소부터 각 요소까지의 누적합 or 누적곱을 계산 (cumsum, cumprod)
np.cumsum(ar1)

array([ 0.286409  ,  0.41707965,  0.72033754, -1.24868477, -1.62602681,
       -1.96784085, -3.12813394, -2.52036225, -1.60262704, -2.35001639,
       -2.65762963, -3.84265078, -3.73611488, -2.21749968, -1.44494863])
```

```python
# 사분위수

# 0.25 : 1 사분위수 / 0.5 : 2 사분위수 (중앙값) / 0.75 : 3 사분위 수
np.quantile(ar1, [0.25, 0.5, 0.75])

array([-0.56236569,  0.1065359 ,  0.45551478])
```

# 기타 함수

```python
# 전체 요소에 대해서 오름차순 정렬
np.sort(ar1)

array([[ 0.13067066,  0.286409  ,  0.30325788],
       [-1.96902231, -0.37734203, -0.34181404],
       [-1.16029309,  0.60777169,  0.91773521],
       [-1.18502116, -0.74738935, -0.30761323],
       [ 0.1065359 ,  0.77255105,  1.51861521]])
```

```python
# 행 방향으로 오름차순 정렬
np.sort(ar1, axis=0)

array([[-1.96902231, -0.37734203, -1.18502116],
       [-1.16029309, -0.30761323, -0.34181404],
       [-0.74738935,  0.13067066,  0.30325788],
       [ 0.1065359 ,  0.60777169,  0.77255105],
       [ 0.286409  ,  1.51861521,  0.91773521]])
```

```python
# 내림차순 정렬
np.sort(ar1)[::-1]

array([[ 0.1065359 ,  0.77255105,  1.51861521],
       [-1.18502116, -0.74738935, -0.30761323],
       [-1.16029309,  0.60777169,  0.91773521],
       [-1.96902231, -0.37734203, -0.34181404],
       [ 0.13067066,  0.286409  ,  0.30325788]])
```

```python
# zip 함수
# 각 객체를 파라미터로 받고, 그 요소들을 tuple의 형태로 반환
numbers = [1, 2, 3]
letters = ['A', 'B', 'C']
for pair in zip(numbers, letters):
  print(pair)
  
(1, 'A')
(2, 'B')
(3, 'C')
```





