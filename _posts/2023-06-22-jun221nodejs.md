---
layout: single
title: "Node.js"
categories: javascript
tag: [vscode, node]
toc: true
author_profile: false
sidebar:
  nav: "docs"
typora-root-url: ../
---

# < Node.js란? >

자바스크립트는 원래 인터넷 브라우저에서 사용하기 위해 만들어졌다

브라우저는 점유율 탈취를 위해 끝없이 발전해왔다
브라우저 전쟁(Browser Wars)

1차 브라우저 전쟁은 마이크로소프트의 인터넷 익스플로러의 승리로 끝났다

2009년, 구글에서 Chrome을 개발했다 => 2차 브라우저 전쟁 시작

사파리, 파이어폭스 등 쟁쟁한 상대가 많았음 
구글은 브라우저 전쟁에서 승리하기 위해서는 더 빠른 속도가 필요하다고 판단 
기존의 느린 자바스크립트의 성능을 좀 더 끌어올려야 한다 생각했고, 그렇게 새로운 자바스크립트 엔진인 V8이 탑재
=> 성능이 점점 좋아지기 시작 

보안, 성능, ... 많은 부분에서 완성도가 높아져갔는데 ...

이제는 충분히 빨라진 이 자바스크립트를 브라우저 밖에서도 사용할 수 있게 하면 어떨까?라는 생각을 하기 시작

그래서 탄생한 것이 Node.js! 자바스크립트 런타임 프로그램

<hr>



# <그래서 Node.js를 왜 배워야 하는가?>

웹개발자가 되기엔 html, css, js 만으로는 부족!

웹이 예전과는 비교할 수 없을만큼 많이 복잡

개발속도뿐만이 아니라, 이후의 유지보수 일 역시 중요하기 때문에 복잡한 절차가 필요해짐 

이것을 위해 Node.js를 사용하게 되었음 

우리가 알고있는 디스코드, 트위치, 스팀 클라이언트, 넷플릭스가 Node.js 기반으로 만들어짐

(여기에 추가로 React라던지 Next.js를 더 공부)

<hr>



# < Node.js의 특징 >

1. 이벤트 기반 동작 (Event Driven)

이벤트 발생 시 해당 이벤트에 미리 설정한 작업을 수행하는 작업 방식 
이벤트는 웹 브라우저 상에서 일어나는 모든 일들을 의미 
클릭, 드래그, 키다운, 새로고침 등 페이지 상에서 할 수 있는 모든 행동들이 이벤트가 될 수 있음

이벤트 기반 동작을 하기 때문에 개발자는 이벤트에 따른 작업을 미리 진행해놔야 한다 

이 때 이벤트 리스너에 함수를 등록하게 되는데 => 콜백 함수 

이렇게 지정을 했다면 사용자가 브라우저 상에서 특정 이벤트를 발생시키면, 해당 이벤트에 등록되어 있는 콜백 함수가 실행됨으로 
이벤트에 대한 작업을 수행한다

이것이 이벤트 기반 동작!

- 개발자가 이벤트 리스너에 콜백 함수를 등록한다
- 클라이언트로부터 이벤트가 발생한다 
- 이벤트에 등록된 콜백함수를 호출해서 작업을 실행한다 

2. Non-Blocking I/O

블로킹 모델은 한 작업이 시작하면 그 작업이 끝날때까지 다른 요청은 작업을 수행하지 못하고 기다려야하는 방식 

노드에서는 하나의 작업을 다른 작업과 동시에 진행할 수 있음 

그래서 노드의 이런 동작을 논 블로킹 입출력 모델이라고 부름 

실행 시간이 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 나중에 오래 걸리는 함수를 실행

3. Thread

Thread란 프로세스 내부에서 실행되는 [흐름의 단위]

Process는 OS로부터 받는 [작업의 단위]

=> 프로세스가 하나의 일이면, 쓰레드는 그 일에 할당된 일꾼

프로세스는 쓰레드를 여러개 만들 수 있기 때문에 하나의 작업을 받으면 여러 쓰레드가 일을 처리하도록 함 

노드는 하나의 프로세스를 만들고, 그 밑에 여러개의 쓰레드를 생성함 

우리가 이 쓰레드들을 모두 관리하면 좋겠지만 ...

아쉽게도 노드에서는 하나의 쓰레드만 직접 제어가 가능함 

=> 노드를 이용할 때 여러개의 프로세스를 만드는 방식으로 이용 !

<hr>



# < SSR vs CSR > 

Rendering : 서버로부터 HTML 파일을 받아 브라우저에 뿌려주는 과정 

브라우저에서 실제로 우리가 보는 화면을 최종적으로 어디서 만들어서 보여주는가, 어떻게 개발하는가에 따라서 CSR, SSR로 나뉜다

CSR은 클라이언트 사이드 렌더링으로, 처음에 브라우저가 서버로부터 HTML을 받아오고 나면, 사용자의 요청에 따라서
js를 통해 view를 동적으로 렌더링 하는 방식 

화면에 보여줄 내용을 클라이언트에서 생성을 하기 때문에 => 클라이언트 사이드 렌더링 

- 처음에 모든 js파일을 다운받아오기 때문에 첫 로딩 속도가 오래 걸림 
- 데이터 요청이 있을 때만 서버에 요청하므로 페이지 전환이 빠르고, 서버에 부담이 적다 

SSR은 서버에 새로운 페이지에 대한 요청을 할 때마다 서버로부터 HTML과 data가 덧붙여진 템플릿을 받아온다. 

요청할 때마다 브라우저의 새로고침이 일어나는 것 ! 

서버에서 view가 어떻게 보여질 지 해석해서 보내주기 때문에 => 서버 사이드 렌더링 

- 요청하는 화면의 내용을 그때그때 다운받기 때문에 첫 로딩속도는 빠름
- 사용자 상호작용에 따라 뷰가 변경될 때마다 서버와 응답을 하기 때문에 서버에 부담 

=> Node.js SSR기반!

<hr>



# < VS Code 단축키 >

- Alt + (↑/↓) : 줄 이동하기
- Alt + Shift + (↑/↓) : 그 줄 복사하기
- Ctrl + F5 : 실행
- Ctrl + / : 주석처리
- Tab / Shift + Tab : 내어쓰기 / 들여쓰기
- Ctrl + Shift + k : 줄 삭제 
- Ctrl + C : 줄 복사





